
Введение в Python
Часть 2
Строки (str)
Специальные символы:

\n - новая строка
\t - табуляция
\r - возврат каретки
Строки в тройных апострофах или кавычках позволяют записывать многострочные блоки текста.

print("""Этот текст
был записан
в нескольких строках""")
Этот текст
был записан
в нескольких строках
Функции для работы со строками
Конкатенация
s1 = 'Hello '
s2 = 'world!'
s3 = s1 + s2  # 'Hello world!'
Дублирование
s4 = s1 * 3  # 'Hello Hello Hello '
Длина
len(s1)  # 6
Методы строк
Поиск подстроки. Возвращает номер первого вхождения или -1
s3.find(s2)  # 6
Поиск подстроки. Возвращает номер последнего вхождения или -1
s3.rfind('o')  # 7
Перевод символов в верхний регистр
s2.upper()  # 'WORLD!'
Перевод символов в нижний регистр
s1.lower()  # 'hello '
Определение начинается ли строка с подстроки
s1.startswith('Hel')  # True
Определение заканчивается строка подстрокой
s1.endswith('lo ')  # True
Разбиение строки
lst = s3.split(' ')  # ['Hello', 'world!']
Объединение строк
'-'.join(lst)  # 'Hello-world!'
Форматирование строки
Позволяет добавлять в строку данных различных типов

'{} or {}'.format('One', 1)  # 'One or 1'
Использование аргументов в произвольном порядке

'{0}, {1} {0}'.format('Бонд', 'Джеймс')  # 'Бонд, Джеймс Бонд'
'Имя: {name} Фамилия: {surname}'.format(name='Вася', surname='Васечкин')  # 'Имя: Вася Фамилия: Васечкин'
Cпецификация и типизация

'Округление: {:.3f}'.format(2/3)  # 'Округление: 0.667'
'Выравнивание: {:05.2f}'.format(5/3)  # 'Выравнивание: 01.67'
'Число по коду: {num:d} {num:c}'.format(num=167)  # 'Число по коду: 167 §'
f - строки
Записи

'Округление: {:.3f}'.format(2/3)
'Выравнивание: {:05.2f}'.format(5/3)
'Число по коду: {num:d} {num:c}'.format(num=167)
эквивалентны записям

f'Округление: {2/3:.3f}'
f'Выравнивание: {5/3:05.2f}'
num = 167
f'Число по коду: {num:d} {num:c}'
Списки (list)
Создание списка
lst_st = list('Строка')  # ['С', 'т', 'р', 'о', 'к', 'а']
lst_rng = list(range(10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
lst_var = [1, 'a', 'abc', None, ['Other', 'list'], 3.14]
Индексирование
lst_st[1]  # 'т'
lst_st[-1]  # 'а'
Срезы
lst_st[1:4]  # ['т', 'р', 'о']
lst_st[:3]  # ['С', 'т', 'р']
lst_st[-3:]  # ['о', 'к', 'а']
lst_rng[:6:2]  # [0, 2, 4]
lst_st[::-1]  # ['а', 'к', 'о', 'р', 'т', 'С']
Генераторы списков
lst_sqr = [i ** 2 for i in range(6)]  # [0, 1, 4, 9, 16, 25]
lst_sqr_even = [i ** 2 for i in range(5) if i % 2 == 0]  # [0, 4, 16]
Длина списка
len(lst_rng)  # 10
Наличие элемента в списке
2 in lst_rng  # True
Методы списков
методы списков, в отличие от строковых методов, изменяют сам список, а потому результат выполнения не нужно записывать в эту переменную
Добавление элемента
lst_st.append('!')  # lst_st -> ['С', 'т', 'р', 'о', 'к', 'а', '!']
Расширение списка
lst_st.extend(['1', '2'])  # lst_st -> ['С', 'т', 'р', 'о', 'к', 'а', '1', '2']
Удаление элемента (первый совпадающий)
lst_st.remove('р')  # lst_st -> ['С', 'т', 'о', 'к', 'а']
Вставка элемента
lst_st.insert(4, 'ч')  # lst_st -> ['С', 'т', 'р', 'о', 'ч', 'к', 'а']
Подсчет элементов
lst_nums = [1, 2, 0, 1, 2, 1]
lst_nums.count(1)  # 3
Сортировка элементов
lst_nums.sort()  # [0, 1, 1, 1, 2, 2]
# Получение элемента 	
l[i]      # 	O(1)
# Размер списка 	
len(l) 	  #     O(1)
# Сравнение списков (==, !=) 	
l1 == l2  # 	O(N)
# Удаление элемента (pop) 	
l.pop()   #     O(1)
l.pop(i)  # 	O(N)
# Расширение 	
l.extend(...)# 	O(len(...))
# Копирование 	
l.copy()  # 	O(N)
# Сортировка 	
l.sort()  # 	O(N Log N) 	
Кортежи (tuple)
Кортеж - неизменяемый список
lst = [1, 2, 3, 4, 5, 6]  # Список
tpl = (1, 2, 3, 4, 5, 6)  # Кортеж
Отличия от списков:

Защита от изменений
Меньший размер
Возможность использовать как ключи словаря
dct = {1: 'a', (2, 3): 'b'}
Операции с кортежами:

Создание
tpl = (1, 2, 3, 4, 5, 6)
tpl = tuple([1, 2, 3, 4, 5, 6])  # Преобразование из списка
tpl = tuple(range(5))  # Преобразование из генератора
tpl = tuple()  # Пустой кортеж
tpl = (1, )  # Кортеж из одного элемета. Запятая обязательна
Разбиение на элементы
a, b = (1, 'c')  # a = 1; b = 'c'
Смена местами значения двух переменных
a, b = b, a
Словари (dict)
Словарь - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами
Создание

dct = {'a': 1, 'b': 2}
dct = dict(a=1, b=2)
dct = dict([('a', 1), ('b', 2)])
dct_frk = dict.fromkeys(['a', 'b'], 1)  # {'a': 1, 'b': 1}
dct_rng = {i: i ** 2 for i in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
Получение элемента

dct['a']  # 1
dct.get('a')  # 1
Методы словарей
Получение пары (ключ, значение)
dct.items()  # Итератор [('a', 1), ('b', 2)]
Получение ключей
dct.keys()  # Итератор ['a', 'b']
Получение значение
dct.values()  # Итератор [1, 2]
Добавление нового словаря (обновляет славарь, возвращает None)
dct.update(new_dct)
Получение элемента и удаление его из словаря
dct.pop('a')  # 1, dct -> {'b': 2}
# Получение элемента 	
d[k] 	  #     O(1)
d.get(k)  # 	O(1)
# Размер словаря 	
len(d) 	  #     O(1)
# Удаление (pop) 	
d.pop(k)  # 	O(1)
# Получение ключей 	
d.keys()  # 	O(1)
Множества (set)
Множество - "контейнер", содержащий не повторяющиеся элементы в случайном порядке
Создание

st = {1, 2, 3, 2, 1}  # {1, 2, 3}
st = set([1, 2, 3, 2, 1])
Методы
Добавление элемента
st.add(4)  # st -> {1, 2, 3, 4}
Добавление другого множества
st.update({})  # st -> {1, 2, 3, 4}
Определение, является ли подмножеством
st.issubset({1, 2, 3, 4})  # True
Объеднинение множеств
st.union({0, 1, 2})  # {0, 1, 2, 3}
Пересечение множеств
st.intersection({0, 1, 2})  # {1, 2}
Неизменяемое множество (frozenset)
frozenset([1, 2, 3, 2, 1])
# Размер множества 	
len(s) 	     #     O(1)
# Сравнение множеств (==, !=) 	
s != t       #     O(len(s))
# Удаление значения (remove) 	
s.remove(..) #     O(1)
# Объединение (union) 	
s | t 	     #     O(len(s)+len(t)) 
# Копирование 	
s.copy()     #	   O(N)
Важно помнить!
Списки, кортежи, словари и множества работают через указатели!
lst1 = [1, 2, 3, 4, 5]
lst2 = lst1

print(lst2)

lst1[1] = 10

print(lst2)
[1, 2, 3, 4, 5]
[1, 10, 3, 4, 5]
lst1 = ['a', 'b', 'c']
lst2 = [1, 2, lst1, 4]

print(lst2)

lst1[1] = 'o'

print(lst2)
[1, 2, ['a', 'b', 'c'], 4]
[1, 2, ['a', 'o', 'c'], 4]
# Рекурсивный список

lst1 = [1, 2, 3, 4, 5]
lst1.append(lst1)

print(lst1)
print(lst1[-1])
print(lst1[-1][-1])
[1, 2, 3, 4, 5, [...]]
[1, 2, 3, 4, 5, [...]]
[1, 2, 3, 4, 5, [...]]
Функции
def mult(x, y):
    return x * y  # Возвращаемое значение

c = mult(3, 5)  # 15
Возврат нескольких значение

def add_mult(x, y):
    return x + y, x * y  # Возвращаемое значение

c, d = add_mult(3, 5)  # 8, 15
Возврат функции

def main_func(n):
    def sub_func(x):
        return x ** n
    return sub_func

f = main_func(3)
c = f(2)  # 8
Аргументы функции

# Значения по умолчанию. y можно не указывать
def func(x, y=2):
    return x ** y

# Вызов функции со значениями в произвольном порядке
func(y=3, x=2)

# Произвольное число аргументов (передаётся как tuple)
def func(*args):
    return sum(args)

func(1, 2, 5, 10)  # 18

# Произвольное число именованных аргументов (передаётся как dict)
def func(**kwargs):
    return kwargs

func(a=1, b=2)  # {'a': 1, 'b': 2}
Анонимные функции (lambda)
Содержат лишь одно выражение, но и выполняются быстрее

func = lambda x, y: x * y
func(3, 5)  # 15
Строки документации
Строка документации — это однострочный или многострочный строковый литерал, разделенный тройными одинарными или двойными кавычками """Описание""" в начале модуля, класса, метода или функции, который описывает, что делает функция.

Только в случае, если это первый оператор в функции, он может быть распознан компилятором байт-кода Python и доступен как атрибуты объекта времени выполнения с помощью метода __doc__ или функции help().

def power(a, b): 
    """Returns arg1 raised to power arg2."""
    return a**b


help(power)
Help on function power in module __main__:

power(a, b)
    Returns arg1 raised to power arg2.

power.__doc__
'Returns arg1 raised to power arg2.'
# Формат numpy
def string_reverse_and_concat(str1, str2):
    """
    Returns the reversed and concated strings

    Parameters
    ----------
    str1 : str
        The string which is to be reversed
    str2 : str
        The string which is to be concated


    Returns
    -------
    result : str
        The string which gets reversed str1 and concated with str2   
    """

    reverse_str1 = str1[::-1]
    result = reverse_str1 + str2
    
    return result
help(string_reverse_and_concat)
Help on function string_reverse_and_concat in module __main__:

string_reverse_and_concat(str1, str2)
    Returns the reversed and concated strings
    
    Parameters
    ----------
    str1 : str
        The string which is to be reversed
    str2 : str
        The string which is to be concated
    
    
    Returns
    -------
    result : str
        The string which gets reversed str1 and concated with str2

Генераторы в Python
Генераторы и итераторы представляют собой инструменты, которые, как правило, используются для поточной обработки данных.

Итератор представляет собой объект перечислитель, который для данного объекта выдает следующий элемент, либо бросает исключение, если элементов больше нет.

Создание итератора
# Из списка
it = iter([1, 2, 5, 3])
print(it)
# Перечисление циклом for
for i in it:
    print(i)
<list_iterator object at 0x7ff0881f7670>
1
2
5
3
# Перечисление с помощью функции next
it = iter([1, 2, 5, 3])
while True:
    print(next(it))
1
2
5
3
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-9-fb8c1e96a5f8> in <module>
      2 it = iter([1, 2, 5, 3])
      3 while True:
----> 4     print(next(it))

StopIteration: 
# Создание бесконечного генератора в функции
def fun_iter(val):
    s = 1
    while True:
        s = s * val
        yield s
        
fit = fun_iter(2)
for i in range(4):
    print(next(fit))
2
4
8
16
# Создание генератора в функции с аргументом
def coroutine(func):
    def iner(*args, **kwargs):
        g = func(*args, **kwargs)
        g.send(None)
        return g
    return iner

@coroutine
def average():
    count = 0
    summ = 0
    average = None
    while True:
        try:
            x = yield average
        except StopIteration:
            print('Done')
            break
        else:
            count += 1
            summ += x
            average = round(summ/count, 2)
fit = average()

#fit.send(None) # or next(fit)
fit.send(5)
fit.send(3)
fit.send(10.5)
6.17
Кэширование функций

import time

# Числа Фибоначчи (чистая рекурсия)
def fib(num:int) -> int:
    if num < 2:
        return num
    return fib(num - 1) + fib(num - 2)
[fib(n) for n in range(16)]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
start = time.perf_counter()
fib(30)
print('Time run:', time.perf_counter() - start)
Time run: 0.2108415920083644
# использование лямбда функции
fib = lambda n: fib(n - 1) + fib(n - 2) if n > 2 else 1
[fib(n) for n in range(16)]
[1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
start = time.perf_counter()
fib(30)
print('Time run:', time.perf_counter() - start)
Time run: 0.13040554299368523
# Использование памяти
M = {0: 0, 1: 1}

def fib(n):
    if n in M:
        return M[n]
    M[n] = fib(n - 1) + fib(n - 2)
    return M[n]
[fib(n) for n in range(16)]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
start = time.perf_counter()
fib(30)
print('Time run:', time.perf_counter() - start)
Time run: 5.626400525216013e-05
from functools import lru_cache

#использование стандартного модуля functools
@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print([fib(n) for n in range(16)])
#print(f'cache_info: \n{fib.cache_info()}')
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
start = time.perf_counter()
fib(30)
print('Time run:', time.perf_counter() - start)
Time run: 8.309299300890416e-05
Файлы
Файл example.txt имеет следующее содержание:
Hello
world!
Открытие файла для чтения

f = open('example.txt')
f.read()  # 'Hello\nworld!\n'
После окончания работы с файлом его обязательно нужно закрыть

f.close()
Конструкция with ... as ... сама происзводит открытие и закрытие файла

with open('example.txt') as f:
    f.read()
Чтение строки файла

with open('example.txt') as f:
    f.readline()  # 'Hello\n'
Режим открытия файла

Открытие файла для чтение 'r'
Открытие файла для записи 'w'
Открытие файла для добавления 'a'
Открытие файла в двоичном режиме 'b'
with open('out.txt', 'w') as f:
    for s in ['It is\n', 'output\n']:
        f.writeline()
Файл out.txt тепреь содержит:
It is
output

Исключения
Конструкция try ... except ... позволяет обрабатывать ошибки/исключения в процессе выполнения программы

s = 1 + '2'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-11-fd1b8605b7a4> in <module>
----> 1 s = 1 + '2'

TypeError: unsupported operand type(s) for +: 'int' and 'str'
try:
    s = 1 + '2'
except TypeError:
    s = 1
print(s)
1
Есть возможность обрабатывать различные исключения

import math
arr = [3, 2.3, '3', 1, '5', 6]
s, k, n = 0, 0, 0
for a in arr:
    try:
        s += a / math.floor(a/2)
    except TypeError:
        print(a, 'is not number')
    except ZeroDivisionError:
        print('Половина от', a, '- ноль')
    except Exception:
        print('Неопределённая ошибка с', a)
    else:
        k += 1
    finally:
        n += 1
print('Половинная сумма для', k, 'элементов из', n, ':', s)
3 is not number
Половина от 1 - ноль
5 is not number
Половинная сумма для 3 элементов из 6 : 7.3
it = iter([1, 2, 5, 3])

# while True:
#     print(next(it))

while True:
    try:
        print(next(it))
    except StopIteration:
        break
1
2
5
3
Задания
Вводится строка. Определить является ли она палиндромом и вывести соответствующее сообщение.
В строке, состоящей из слов, разделенных пробелом, найти самое длинное слово.
Генерируется список случайных целых чисел. Определить, сколько в нем четных чисел, а сколько нечетных.
Дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Заменить в строке все слова, входящие в словарь, как ключи, на их синонимы.
Напишите функцию fib(n), которая по данному целому неотрицательному n возвращает n-e число Фибоначчи. В этой задаче нельзя использовать циклы — используйте рекурсию.
Сосчитайте количество строк, слов и букв в произвольном текстовом файле. (слова разделены пробелом, \n не считается символом)
Создайте генератор, выводящий бесконечную геометрическую прогрессию. Параметры прогрессии задаются через аргументы генератора
Лабораторные работы
Важно помнить:

весь код оформляется в соответствии с PEP8.
код разбивается на функции (вне функций только импорты и вызов основной функции)
функции документируются
необходимо проверять размер матриц на корректность размерности
Лабораторная работа 2.1. Перемножение матриц
Реализовать скрипт matrix_mult.py

Входные параметры скрипта:

Путь к файлу с матрицами. Например, matrix.txt. Внутри файла заданы две целочисленные матрицы.
Путь к файлу с результатом работы программы
Выходные значения: записывает результирующую матрицу в файл с результатом работы программы

Что должен делать скрипт:

Прочитать файл, используя встроенные функции Python для работы с файлами.
Преобразовать прочитанные строки в матрицы. Матрицы реализовать используя стандартные типы данных Python. Например, список списков.
Найти произведение полученных матриц.
Записать результат произведения в выходной файл.
Пример матриц в файле:

1 2 1 2 0 3 2 4
2 3 5 1 3 7 5 2
1 3 5 8 2 7 0 0
4 5 6 7 2 1 3 5

4 5 5 5
1 2 3 3
0 0 0 0
0 0 1 1
1 1 2 2
3 2 1 1
-2 -3 -1 0
1 2 3 1

Лабораторная работа 2.2. Операция свёртки
Реализовать скрипт matrix_mult.py

Входные параметры скрипта:

Путь к файлу с матрицами. Например, matrix.txt. Внутри файла заданы две целочисленные матрицы (размер второй матрицы не больше первой).
Путь к файлу с результатом работы программы
Выходные значения: записывает результирующую матрицу в файл с результатом работы программы

Что должен делать скрипт:

Прочитать файл, используя встроенные функции Python для работы с файлами.
Преобразовать прочитанные строки в матрицы. Матрицы реализовать используя стандартные типы данных Python. Например, список списков.
Найти свёртку первой матрицы со второй. Вторую матрицу использовать как ядро свёртки. Не нужно добавлять падинг, не нужно использовать шаг ядра свёртки != 1. Wiki YouTube
Записать результат произведения в выходной файл.